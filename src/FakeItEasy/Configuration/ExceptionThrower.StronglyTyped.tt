<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ include file="../CodeGen/Ordinals.ttinclude" #>
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a T4 template.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------
namespace FakeItEasy.Configuration
{
    using System;
    using System.Diagnostics.CodeAnalysis;
    using FakeItEasy.Core;

    public partial interface IExceptionThrowerConfiguration<out TInterface>
    {
<# GenerateMethodDeclarations(); #>
    }

    internal partial class RuleBuilder
    {
        private const string NameOfThrowsFeature = "throws";

<# GenerateMethodImplementations("IVoidConfiguration"); #>
        public partial class ReturnValueConfiguration<TMember>
        {
<# GenerateMethodImplementations("IReturnValueConfiguration<TMember>", "    "); #>
        }
    }

    internal partial class AnyCallConfiguration
    {
        private const string NameOfThrowsFeature = "throws";

<# GenerateMethodImplementations("IVoidConfiguration"); #>
    }

    internal partial class PropertySetterConfiguration<TValue>
    {
        private const string NameOfThrowsFeature = "throws";

<# GenerateMethodImplementations("IPropertySetterConfiguration"); #>
        private partial class PropertySetterAdapter
        {
<# GenerateMethodImplementations("IPropertySetterConfiguration"); #>
        }
    }
}
<#+

void GenerateMethodDeclarations()
{
    for (int typeParametersCount = 1; typeParametersCount <= 8; typeParametersCount++)
    {
        var typeParamList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => "T" + i));
#>
        /// <summary>
        /// Throws the specified exception when the currently configured
        /// call gets called.
        /// </summary>
        /// <param name="exceptionFactory">A function that returns the exception to throw when invoked.</param>
<#+
        for (int i = 1; i <= typeParametersCount; i++)
        {
#>
        /// <typeparam name="T<#= i #>">The type of the <#= Ordinals[i] #> argument of the faked method call.</typeparam>
<#+
        }
#>
        /// <returns>Configuration object.</returns>
        /// <exception cref="FakeConfigurationException">The signatures of the faked method and the <paramref name="exceptionFactory"/> do not match.</exception>
        IAfterCallConfiguredConfiguration<TInterface> Throws<<#= typeParamList #>>(Func<<#= typeParamList #>, Exception> exceptionFactory);

<#+
    }
}

void GenerateMethodImplementations(string configurationInterface, string indent = null)
{
    if (indent != null)
    {
        PushIndent(indent);
    }

    for (int typeParametersCount = 1; typeParametersCount <= 8; typeParametersCount++)
    {
        var typeParamList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => "T" + i));
        var argumentList = string.Join(", ", Enumerable.Range(1, typeParametersCount).Select(i => $"call.GetArgument<T{i}>({i - 1})"));
#>
        /// <summary>
        /// Throws the specified exception when the currently configured
        /// call gets called.
        /// </summary>
        /// <param name="exceptionFactory">A function that returns the exception to throw when invoked.</param>
<#+
        for (int i = 1; i <= typeParametersCount; i++)
        {
#>
        /// <typeparam name="T<#= i #>">The type of the <#= Ordinals[i] #> argument of the faked method call.</typeparam>
<#+
        }
#>
        /// <returns>Configuration object.</returns>
        /// <exception cref="FakeConfigurationException">The signatures of the faked method and the <paramref name="exceptionFactory"/> do not match.</exception>
        public IAfterCallConfiguredConfiguration<<#= configurationInterface #>> Throws<<#= typeParamList #>>(Func<<#= typeParamList #>, Exception> exceptionFactory)
        {
            Guard.AgainstNull(exceptionFactory, nameof(exceptionFactory));

            return this.Throws((IFakeObjectCall call) =>
            {
                ValueProducerSignatureHelper.AssertThatValueProducerSignatureSatisfiesCallSignature(call.Method, exceptionFactory.GetMethodInfo(), NameOfThrowsFeature);

                return exceptionFactory(<#= argumentList #>);
            });
        }

<#+
    }

    if (indent != null)
    {
        PopIndent();
    }
}
#>
